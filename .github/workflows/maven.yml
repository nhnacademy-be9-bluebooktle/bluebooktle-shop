name: CI & CD

on:
  push:
    branches: [ develop ]
    paths:
      - 'backend-server/**'
      - 'frontend-server/**'
      - 'gateway-server/**'
      - 'eureka-server/**'
      - 'common-module/**'
      - 'auth-server/**'
  pull_request:
    branches: [ develop ]
    paths:
      - 'backend-server/**'
      - 'frontend-server/**'
      - 'gateway-server/**'
      - 'eureka-server/**'
      - 'common-module/**'
      - 'auth-server/**'

jobs:
  detect_changes:
    # PR이 '병합되어' 닫힌 경우에만 이 작업 실행
    runs-on: ubuntu-latest
    outputs:
      changed: ${{ steps.list.outputs.changed }}
    steps:
      - name: Checkout develop branch (after merge)
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.pull_request.base.ref }} # 병합된 develop 브랜치 체크아웃
          fetch-depth: 0 # paths-filter가 이전 커밋과 비교하려면 전체 히스토리 필요

      - name: Filter changed paths (for merged PR)
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            backend-server:
              - 'backend-server/**'
            frontend-server:
              - 'frontend-server/**'
            gateway-server:
              - 'gateway-server/**'
            eureka-server:
              - 'eureka-server/**'
            common-module:
              - 'common-module/**'
            auth-server:
              - 'auth-server/**'

      - name: Generate final changed-services list
        id: list
        run: |
          modules=()
          [[ "${{ steps.filter.outputs.backend-server }}"  == "true" ]] && modules+=("backend-server")
          [[ "${{ steps.filter.outputs.frontend-server }}" == "true" ]] && modules+=("frontend-server")
          [[ "${{ steps.filter.outputs.gateway-server }}"  == "true" ]] && modules+=("gateway-server")
          [[ "${{ steps.filter.outputs.eureka-server }}"   == "true" ]] && modules+=("eureka-server")
          [[ "${{ steps.filter.outputs.auth-server }}"     == "true" ]] && modules+=("auth-server")
          # common-module이 변경되면 모든 서비스 재배포
          if [[ "${{ steps.filter.outputs.common-module }}" == "true" ]]; then
            for svc in backend-server frontend-server gateway-server eureka-server auth-server; do
              # 이미 추가된 모듈은 중복 추가 방지
              if [[ ! " ${modules[*]} " =~ " $svc " ]]; then
                modules+=("$svc")
              fi
            done
          fi
          echo "changed=${modules[*]}" >> $GITHUB_OUTPUT

  build:
    needs: detect_changes
    # PR이 병합되었고, 변경된 모듈이 있을 경우에만 실행
    if: needs.detect_changes.outputs.changed != ''
    runs-on: ubuntu-latest
    environment:
      name: 'dev' # develop 브랜치로 병합 시 'dev' 환경 사용

    env:
      CONFIG_SERVER_URI: ${{ secrets.CONFIG_SERVER_URI }}
      SPRING_PROFILES_ACTIVE: 'dev'
      JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}

      SPRING_DATASOURCE_URL: ${{ secrets.SPRING_DATASOURCE_URL }}
      SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
      SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}

      SPRING_DATA_REDIS_PASSWORD: ${{ secrets.SPRING_DATA_REDIS_PASSWORD }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Java 21
        uses: actions/setup-java@v4
        with:
          distribution: 'temurin'
          java-version: '21'
          cache: 'maven'

      - name: Clean & Build changed-services
        run: |
          MODULE_CSV=$(echo "${{ needs.detect_changes.outputs.changed }}" | sed 's/ /,/g')
          echo "▶ Building modules: $MODULE_CSV"
          # 전체 프로젝트를 빌드하되, 변경된 모듈만 패키징 (-pl 옵션)
          # -am 옵션은 지정된 모듈과 그 의존 관계에 있는 모듈들도 함께 빌드
          mvn -B clean package -pl "$MODULE_CSV" -am -DskipTests

      - name: Upload built JARs
        uses: actions/upload-artifact@v4
        with:
          name: jars
          path: '**/target/*.jar' # 각 모듈의 target/*.jar 파일을 찾아서 업로드
          if-no-files-found: error

  deploy:
    needs: [detect_changes, build]
    # PR이 병합되었고, 변경된 모듈이 있을 경우에만 실행
    if: github.event.pull_request.merged == true && needs.detect_changes.outputs.changed != ''
    runs-on: ubuntu-latest
    environment:
      name: 'dev' # develop 브랜치로 병합 시 'dev' 환경 사용

    env:
      # === Secret 값 참조 (build job과 동일하게 설정) ===
      CONFIG_SERVER_URI: ${{ secrets.CONFIG_SERVER_URI }}
      SPRING_PROFILES_ACTIVE: 'dev'
      JWT_SECRET_KEY: ${{ secrets.JWT_SECRET_KEY }}

      SPRING_DATASOURCE_URL: ${{ secrets.SPRING_DATASOURCE_URL }}
      SPRING_DATASOURCE_USERNAME: ${{ secrets.SPRING_DATASOURCE_USERNAME }}
      SPRING_DATASOURCE_PASSWORD: ${{ secrets.SPRING_DATASOURCE_PASSWORD }}

      SPRING_DATA_REDIS_PASSWORD: ${{ secrets.SPRING_DATA_REDIS_PASSWORD }}

      # Eureka 관련 정보는 startup.sh에서 직접 사용하므로 여기서 전달할 필요 없음
      # EUREKA_ID: ${{ secrets.EUREKA_ID }}
      # EUREKA_PASSWORD: ${{ secrets.EUREKA_PASSWORD }}

    steps:
      - name: Download JARs
        uses: actions/download-artifact@v4
        with:
          name: jars # build 작업에서 업로드한 아티팩트 이름
          path: downloaded_jars # 다운로드 받을 경로

      - name: Check Variables in Job Environment (Safer Debug)
        run: |
          echo "--- Checking Variables in Job Environment (deploy job) ---"
          if [ -n "${{ env.CONFIG_SERVER_URI }}" ]; then echo "DEBUG_JOB_ENV: CONFIG_SERVER_URI is SET"; else echo "DEBUG_JOB_ENV: CONFIG_SERVER_URI is NOT SET"; fi
          if [ -n "${{ env.SPRING_PROFILES_ACTIVE }}" ]; then echo "DEBUG_JOB_ENV: SPRING_PROFILES_ACTIVE is [${{ env.SPRING_PROFILES_ACTIVE }}]"; else echo "DEBUG_JOB_ENV: SPRING_PROFILES_ACTIVE is NOT SET"; fi
          if [ -n "${{ env.JWT_SECRET_KEY }}" ]; then echo "DEBUG_JOB_ENV: JWT_SECRET_KEY is SET (masked)"; else echo "DEBUG_JOB_ENV: JWT_SECRET_KEY is NOT SET"; fi
          if [ -n "${{ env.SPRING_DATASOURCE_URL }}" ]; then echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_URL is SET"; else echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_URL is NOT SET"; fi
          if [ -n "${{ env.SPRING_DATASOURCE_USERNAME }}" ]; then echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_USERNAME is SET"; else echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_USERNAME is NOT SET"; fi
          if [ -n "${{ env.SPRING_DATASOURCE_PASSWORD }}" ]; then echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_PASSWORD is SET (masked)"; else echo "DEBUG_JOB_ENV: SPRING_DATASOURCE_PASSWORD is NOT SET"; fi
          if [ -n "${{ env.SPRING_DATA_REDIS_PASSWORD }}" ]; then echo "DEBUG_JOB_ENV: SPRING_DATA_REDIS_PASSWORD is SET (masked)"; else echo "DEBUG_JOB_ENV: SPRING_DATA_REDIS_PASSWORD is NOT SET"; fi
          echo "------------------------------------------------------------"

      - name: Upload JARs to remote server
        uses: appleboy/scp-action@master
        with:
          host: ${{ secrets.SSH_IP }}
          username: ${{ secrets.SSH_ID }}
          password: ${{ secrets.SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          source: "downloaded_jars/" # 다운로드된 JAR들이 있는 디렉토리
          target: "~/app/jars/" # 원격 서버의 업로드 대상 디렉토리 (하위 모듈 디렉토리 구조 유지를 위해 끝에 / 추가)
          # strip_components: 1 # downloaded_jars 디렉토리 자체는 제외하고 내용만 복사하려면 사용. 여기서는 모듈별 디렉토리 유지를 위해 사용 안 함.

      - name: Execute deployment script on remote server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.SSH_IP }}
          username: ${{ secrets.SSH_ID }}
          password: ${{ secrets.SSH_PASSWORD }}
          port: ${{ secrets.SSH_PORT }}
          capture_stdout: true
          script: |
            echo "--- Preparing to call startup.sh on remote server ---"

            # GitHub Actions의 env 컨텍스트 및 secrets를 원격 서버의 환경 변수로 export
            # env 블록을 통해 설정된 변수들
            export CONFIG_SERVER_URI='${{ env.CONFIG_SERVER_URI }}'
            export SPRING_PROFILES_ACTIVE='${{ env.SPRING_PROFILES_ACTIVE }}'
            export JWT_SECRET_KEY='${{ env.JWT_SECRET_KEY }}' # 값에 특수문자가 있을 수 있으므로 작은따옴표로 감싸는 것이 안전합니다.
            export SPRING_DATASOURCE_URL='${{ env.SPRING_DATASOURCE_URL }}'
            export SPRING_DATASOURCE_USERNAME='${{ env.SPRING_DATASOURCE_USERNAME }}'
            export SPRING_DATASOURCE_PASSWORD='${{ env.SPRING_DATASOURCE_PASSWORD }}'
            export SPRING_DATA_REDIS_PASSWORD='${{ env.SPRING_DATA_REDIS_PASSWORD }}'

            # secrets에서 직접 가져와서 export 하는 변수들 (기존 방식 유지)
            export EUREKA_ID='${{ secrets.EUREKA_ID }}'
            export EUREKA_PASSWORD='${{ secrets.EUREKA_PASSWORD }}'

            # (선택적) 디버깅: 원격 서버에 export된 환경 변수 확인 (실제 값 출력은 보안상 주의)
            echo "DEBUG_SSH_ACTION: Remotely exported SPRING_PROFILES_ACTIVE is [$SPRING_PROFILES_ACTIVE]" # $변수명은 원격 쉘에서 해석됨
            if [ -n "$JWT_SECRET_KEY" ]; then echo "DEBUG_SSH_ACTION: JWT_SECRET_KEY on remote is SET"; else echo "DEBUG_SSH_ACTION: JWT_SECRET_KEY on remote is NOT SET"; fi
            # 필요한 다른 변수들도 위와 유사하게 확인 가능합니다.

            chmod +x ~/startup.sh

            # 변경된 모듈들에 대해 반복 실행
            for MOD in ${{ needs.detect_changes.outputs.changed }}; do
              echo "▶ Rolling deploy for module: $MOD"
              # startup.sh는 이제 위에서 export된 환경 변수들을 직접 참조합니다.
              # 모듈 이름($MOD)은 여전히 인자로 전달하거나,
              # 또는 export DEPLOY_MODULE="$MOD" 와 같이 환경변수로 설정하고 startup.sh에서 DEPLOY_MODULE을 사용하도록 할 수 있습니다.
              # 여기서는 모듈 이름을 첫 번째 인자로 전달하는 방식을 유지합니다.
              # startup.sh 스크립트가 이 인자와 export된 환경 변수들을 사용하도록 수정되어야 합니다.
              ~/startup.sh "$MOD"
            done